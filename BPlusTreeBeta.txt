using System;
using System.Collections.Generic;
using System.Linq;
using System.Numerics;
using System.Text;
using System.Text.RegularExpressions;
class BPlusTree<T>
{
    const int ORD = 3; // #keys on split
    const int M = ORD * 2 + 1; // the most children we can have
    public int size { get; private set; }
    abstract class AbsNode
    {
        internal AbsNode parent;
    }
    class Leaf : AbsNode
    {
        public T val;
    }
    class ActiveNode : AbsNode
    {
        internal int key;
        internal AbsNode Left, Right;
    }
    class Node : AbsNode
    {
        public List<int> keys = new List<int>(M - 1);
        public List<AbsNode> Children = new List<AbsNode>(M);
        public Node SiblingL, SiblingR;
        public ActiveNode Split(int place)
        //assert: Children[place] is ActiveNode
        //assert: $Sizes == ORD*2
        {
            var E = Children[place] as ActiveNode;
            var Next = new Node();
            Next.SiblingR = this.SiblingR;
            Next.SiblingL = this;
            this.SiblingR = Next;
            var Mid = new ActiveNode();
            Mid.parent = this.parent;
            Mid.Left = this;
            this.parent = Mid;
            Mid.Right = Next;
            Next.parent = Mid;
            //implant keys and values;
            switch (place - ORD)
            {
                case < 0:
                    Next.keys.AddRange(this.keys.Skip(ORD));
                    Next.Children.AddRange(this.Children.Skip(ORD));
                    Mid.key = this.keys[ORD - 1];
                    this.Children.RemoveRange(ORD, ORD + 1);
                    this.keys.RemoveRange(ORD - 1, ORD + 1);
                    this.keys.Insert(place, E.key);
                    this.Children[place] = E.Right;
                    this.Children.Insert(place, E.Left);
                    break;
                case 0:
                    Next.keys.AddRange(this.keys.Skip(ORD));
                    this.Children[ORD] = E.Left;
                    Next.Children.Add(E.Right);
                    Next.Children.AddRange(this.Children.Skip(ORD + 1));
                    Mid.key = E.key;
                    this.Children.RemoveRange(ORD + 1, ORD);
                    this.keys.RemoveRange(ORD, ORD);
                    break;
                case > 0:
                    //TODO:
                    break;
                default:
            }
        }
    }
}